# LLVM 編譯器的 IR 中間碼解析

* [第一章：介紹 LLVM IR](1.0)
    * [1.1 LLVM 的背景與概述](1.1)
    * [1.2 LLVM IR 是什麼？](1.2)
    * [1.3 LLVM IR 的設計哲學與特性](1.3)
    * [1.4 LLVM IR 與其他中間語言的比較](1.4)

* [第二章：LLVM IR 的基本結構](2.0)
    * [2.1 模塊（Module）與單位（Unit）](2.1)
    * [2.2 函數（Function）與基本塊（Basic Block）](2.2)
    * [2.3 指令（Instruction）與操作碼（Opcode）](2.3)
    * [2.4 值（Value）與類型（Type）](2.4)
    * [2.5 符號表（Symbol Table）與符號屬性（Attributes）](2.5)

* [第三章：LLVM IR 的數值表示](3.0)
    * [3.1 整數（Integer）](3.1)
    * [3.2 浮點數（Floating Point）](3.2)
    * [3.3 運算表達式（Expression）](3.3)
    * [3.4 陣列（Array）與結構（Structure）](3.4)
    * [3.5 指針（Pointer）與位址空間（Address Space）](3.5)

* [第四章：LLVM IR 的控制流](4.0)
    * [4.1 條件分支（Conditional Branch）](4.1)
    * [4.2 迴圈（Loop）](4.2)
    * [4.3 Switch 與多路分支（Switch and Multiway Branch）](4.3)
    * [4.4 异常處理（Exception Handling）](4.4)
    * [4.5 函數呼叫（Function Call）](4.5)

* [第五章：LLVM IR 的優化與分析](5.0)
    * [5.1 最佳化編譯的基本原理](5.1)
    * [5.2 基於 LLVM 的優化技術概述](5.2)
    * [5.3 代數優化（Algebraic Optimization）](5.3)
    * [5.4 雜湊值編碼（Hashing and Caching）](5.4)
    * [5.5 归納變項的優化（Induction Variable Optimization）](5.5)

* [第六章：LLVM IR 的目標碼生成](6.0)
    * [6.1 目標碼生成的基本原理](6.1)
    * [.2 LLVM 中的指令選擇（Instruction Selection）](6.2)
    * [6.3 寄存器分配（Register Allocation）](6.3)
    * [6.4 目標模塊（Target Module）與目標資訊（Target Information）](6.4)
    * [6.5 目標碼呈現（Target Code Generation）](6.5)

* [第七章：LLVM IR 的前端與後端](7.0)
    * [7.1 前端（Frontend）簡介](7.1)
    * [7.2 前端的工作流程與結構](7.2)
    * [7.3 支援的語言與編譯工具](7.3)
    * [7.4 後端（Backend）簡介](7.4)
    * [7.5 後端的工作流程與結構](7.5)

* [第八章：使用 LLVM IR 編寫嵌入式軟體](8.0)
    * [8.1 嵌入式系統介紹](8.1)
    * [8.2 嵌入式系統中的編譯與優化](8.2)
    * [8.3 嵌入式系統的開發工具](8.3)
    * [8.4 嵌入式系統中的代碼執行與調試](8.4)
    * [8.5 實際案例：使用 LLVM IR 編寫嵌入式軟體](8.5)

* [第九章：高級技術與未來發展](9.0)
    * [9.1 LLVM IR 的擴展與延伸](9.1)
    * [9.2 LLVM 在 GPU 編程的應用](9.2)
    * [9.3 LLVM 在深度學習中的應用](9.3)
    * [9.4 LLVM IR 的可擴展性與彈性](9.4)
    * [9.5 LLVM 的未來趨勢與發展方向](9.5)
